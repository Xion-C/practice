// Generated by transforming |cwd:///work-in-progress/2.7.2-bisonified.y| on 2016-11-23 at 15:46:56 +0000
%{
    #include "includes/ast.h"
	#include <iostream>
	#include <map>
	#include <cmath>

	int yylex ();
	extern char *yytext;
	void yyerror (const char *);

	PoolOfNodes& pool = PoolOfNodes::getInstance(); //prevent memory leak
    Node* temp[64];
    int tempcount = 0;
%}


%union {
  Node* node;
  int intNumber;
  float fltNumber;
  char *identifier;
  int op;
}

%token<intNumber> INT
%token<fltNumber> FLOAT
%token<identifier> NAME

%token<op> PLUS MINUS STAR SLASH PERCENT DOUBLESLASH DOUBLESTAR
%token<op> EQUAL PLUSEQUAL MINEQUAL
%token<op> STAREQUAL SLASHEQUAL PERCENTEQUAL
%token<op> DOUBLESTAREQUAL DOUBLESLASHEQUAL
%token<op> LESS GREATER EQEQUAL
%token<op> GREATEREQUAL LESSEQUAL NOTEQUAL

%type<op> pick_multop pick_PLUS_MINUS pick_unop augassign comp_op

%type<node> atom power factor term
%type<node> arith_expr shift_expr and_expr xor_expr expr
%type<node> comparison not_test and_test or_test test testlist
%type<node> expr_stmt
%type<node> pick_yield_expr_testlist yield_expr
%type<node> star_EQUAL
%type<node> small_stmt simple_stmt stmt
%type<node> pick_NEWLINE_stmt star_NEWLINE_stmt file_input start
%type<node> opt_yield_test pick_yield_expr_testlist_comp
%type<node> testlist_comp star_COMMA_test opt_test
%type<node> print_stmt star_trailer
%type<node> compound_stmt if_stmt funcdef
%type<node> flow_stmt return_stmt
%type<node> suite plus_stmt

// %token NUMBER
%token IMAG

// 83 tokens, in alphabetical order:
%token AMPEREQUAL AMPERSAND AND AS ASSERT AT BACKQUOTE BAR BREAK CIRCUMFLEX
%token CIRCUMFLEXEQUAL CLASS COLON COMMA CONTINUE DEDENT DEF DEL DOT
%token ELIF ELSE ENDMARKER
%token  EXCEPT EXEC FINALLY FOR FROM GLOBAL GRLT
%token IF IMPORT IN INDENT IS LAMBDA LBRACE LEFTSHIFT LEFTSHIFTEQUAL
%token LPAR LSQB NEWLINE NOT
%token OR PASS PRINT RAISE RBRACE RETURN
%token RIGHTSHIFT RIGHTSHIFTEQUAL RPAR RSQB SEMI
%token STRING TILDE TRY VBAREQUAL WHILE WITH YIELD

%start start

%locations

%%

start
    : file_input
    {
        $$ = $1;
        // std::cout << "at beginning" << std::endl;
        // if ($1) { ($1)->eval()->print(); }
    }
    ;
file_input // Used in: start
    : star_NEWLINE_stmt ENDMARKER
        { $$ = $1; }
    ;
pick_NEWLINE_stmt // Used in: star_NEWLINE_stmt
    : NEWLINE { $$ = NULL; }
    | stmt
        {
            static int n = 0;
            std::cout << "stmt : " << n++ << std::endl;
            $$ = $1;
        }
    ;
star_NEWLINE_stmt // Used in: file_input, star_NEWLINE_stmt
    : star_NEWLINE_stmt pick_NEWLINE_stmt
    {
        // if ($1) {
        //     $$ = $1;
        // }
        // else {
        //     $$ = $2;
        // }
        // if ($1) { delete [] $1; }
        $$ = $2;
    }
    | %empty { $$ = NULL; }
    ;
decorator // Used in: decorators
	: AT dotted_name LPAR opt_arglist RPAR NEWLINE
	| AT dotted_name NEWLINE
	;
opt_arglist // Used in: decorator, trailer
	: arglist
	| %empty
	;
decorators // Used in: decorators, decorated
	: decorators decorator
	| decorator
	;
decorated // Used in: compound_stmt
	: decorators classdef
	| decorators funcdef
	;
funcdef // Used in: decorated, compound_stmt
    : DEF NAME parameters COLON suite
        {
            std::cout << "func define" << std::endl;
            $$ = nullptr;
            delete [] $2;
        }
    ;
parameters // Used in: funcdef
	: LPAR varargslist RPAR
	| LPAR RPAR
	;
varargslist // Used in: parameters, old_lambdef, lambdef
	: star_fpdef_COMMA pick_STAR_DOUBLESTAR
	| star_fpdef_COMMA fpdef opt_EQUAL_test opt_COMMA
	;
opt_EQUAL_test // Used in: varargslist, star_fpdef_COMMA
	: EQUAL test
	| %empty
	;
star_fpdef_COMMA // Used in: varargslist, star_fpdef_COMMA
	: star_fpdef_COMMA fpdef opt_EQUAL_test COMMA
	| %empty
	;
opt_DOUBLESTAR_NAME // Used in: pick_STAR_DOUBLESTAR
    : COMMA DOUBLESTAR NAME { delete [] $3; }
    | %empty
    ;
pick_STAR_DOUBLESTAR // Used in: varargslist
    : STAR NAME opt_DOUBLESTAR_NAME { delete [] $2; }
    | DOUBLESTAR NAME { delete [] $2; }
    ;
opt_COMMA // Used in: varargslist, opt_test, opt_test_2, testlist_safe, listmaker, testlist_comp, pick_for_test_test, pick_for_test, pick_argument
    : COMMA
    | %empty
    ;
fpdef // Used in: varargslist, star_fpdef_COMMA, fplist, star_fpdef_notest
    : NAME { delete [] $1; }
    | LPAR fplist RPAR
    ;
fplist // Used in: fpdef
    : fpdef star_fpdef_notest COMMA
    | fpdef star_fpdef_notest
    ;
star_fpdef_notest // Used in: fplist, star_fpdef_notest
    : star_fpdef_notest COMMA fpdef
    | %empty
    ;
stmt // Used in: pick_NEWLINE_stmt, plus_stmt
    : simple_stmt { $$ = $1; }
    | compound_stmt
        {
            $$ = $1;
            std::cout << "stmt: compound_stmt" << std::endl;
        }
    ;
simple_stmt // Used in: stmt, suite
    : small_stmt star_SEMI_small_stmt SEMI NEWLINE
        {
            std::cout << "simple_stmt 1 impossible" << std::endl;
            $$ = $1;
        }
    | small_stmt star_SEMI_small_stmt NEWLINE
        {
            // std::cout << "simple_stmt 2" << std::endl;
            $$ = $1;
            // ($1)->eval()->print();
        }
    ;
star_SEMI_small_stmt // Used in: simple_stmt, star_SEMI_small_stmt
    : star_SEMI_small_stmt SEMI small_stmt
    | %empty
    ;
small_stmt // Used in: simple_stmt, star_SEMI_small_stmt
    : expr_stmt
        { $$ = $1; }
    | print_stmt
        {
            //just print, no need to pass the node
            $$ = NULL;
        }
    | del_stmt { $$ = NULL; std::cout << "impossible" << std::endl; }
    | pass_stmt { $$ = NULL; std::cout << "impossible" << std::endl; }
    | flow_stmt
        {
            $$ = NULL;
            std::cout << "flow" << std::endl;
        }
    | import_stmt { $$ = NULL; std::cout << "impossible" << std::endl; }
    | global_stmt { $$ = NULL; std::cout << "impossible" << std::endl; }
    | exec_stmt { $$ = NULL; std::cout << "impossible" << std::endl; }
    | assert_stmt { $$ = NULL; std::cout << "impossible" << std::endl; }
    ;
expr_stmt // Used in: small_stmt
	: testlist augassign pick_yield_expr_testlist
        {
            // std::cout << "expr_stmt1" << std::endl;
            switch ($2) {
                case OP_PLUSEQUAL:
                    $$ = new PlusAsgBinaryNode($1, $3);
                    pool.add($$);
                break;
                case OP_MINEQUAL:
                    $$ = new MinAsgBinaryNode($1, $3);
                    pool.add($$);
                break;
                case OP_STAREQUAL:
                    $$ = new MulAsgBinaryNode($1, $3);
                    pool.add($$);
                break;
                case OP_SLASHEQUAL:
                    $$ = new DivAsgBinaryNode($1, $3);
                    pool.add($$);
                break;
                case OP_PERCENTEQUAL:
                    $$ = new ModAsgBinaryNode($1, $3);
                    pool.add($$);
                break;
                case OP_DOUBLESTAREQUAL:
                    $$ = new ExpAsgBinaryNode($1, $3);
                    pool.add($$);
                break;
                case OP_DOUBELSLASHEQUAL:
                    $$ = new FlrDivAsgBinaryNode($1, $3);
                    pool.add($$);
                break;
                case 0:
                    std::cout << "augassign error" << std::endl;
                break;
            }
        }
    | testlist star_EQUAL
        {
            if ($2) {
                // std::cout << "expr_stmt2" << std::endl;
                $$ = new AsgBinaryNode($1, $2);
                pool.add($$);

                tempcount--;
                if (tempcount) { //not only one EQUAL
                    tempcount--;
                    Node* equ;
                    for( ; tempcount>=0; tempcount--) {
                        equ = new AsgBinaryNode(temp[tempcount], $2);
                        pool.add(equ);
                    }
                }
                if(tempcount < 0) {
                    tempcount = 0;
                }
            }
            else {
                $$ = $1;
                //($1)->eval()->print();
            }
        }
    ;
pick_yield_expr_testlist // Used in: expr_stmt, star_EQUAL
    : yield_expr
        {
            $$ = $1;
            // std::cout << "pick_yield_expr_testlist1" << std::endl;
        }
    | testlist
        {
            $$ = $1;
            // std::cout << "pick_yield_expr_testlist2" << std::endl;
        }
    ;
star_EQUAL // Used in: expr_stmt, star_EQUAL
    : star_EQUAL EQUAL pick_yield_expr_testlist
        {
            // if ($1 == NULL)  //means this is the bottom of the equal tree
            $$ = $3;
            //($3)->print();
            temp[tempcount++] = $3;
            // std::cout << "star_EQUAL1" << std::endl;
        }
    | %empty
        {
            $$ = nullptr;
            // std::cout << "star_EQUAL2" << std::endl;
        }
    ;
augassign // Used in: expr_stmt
    : PLUSEQUAL { $$ = $1; }
    | MINEQUAL { $$ = $1; }
    | STAREQUAL { $$ = $1; }
    | SLASHEQUAL { $$ = $1; }
    | PERCENTEQUAL { $$ = $1; }
    | AMPEREQUAL { $$ = 0; }
    | VBAREQUAL { $$ = 0; }
    | CIRCUMFLEXEQUAL { $$ = 0; }
    | LEFTSHIFTEQUAL { $$ = 0; }
    | RIGHTSHIFTEQUAL { $$ = 0; }
    | DOUBLESTAREQUAL { $$ = $1; }
    | DOUBLESLASHEQUAL { $$ = $1; }
    ;
print_stmt // Used in: small_stmt
	: PRINT opt_test
        {
            $$ = new PrintNode($2);
            pool.add($$);
            // std::cout << "print_stmt1" << std::endl;
        }
	| PRINT RIGHTSHIFT test opt_test_2
        {
            $$ = NULL;
            // std::cout << "print_stmt2" << std::endl;
        }
	;
star_COMMA_test // Used in: star_COMMA_test, opt_test, listmaker, testlist_comp, testlist, pick_for_test
	: star_COMMA_test COMMA test
        {
            $$ = $1; //should always be NULL
            // if ($3) {
            //     ($3)->eval()->print();
            // }
        }
	| %empty { $$ = NULL; }
	;
opt_test // Used in: print_stmt
	: test star_COMMA_test opt_COMMA
        {
            $$ = $1;
            // if ($1) {
            //     ($1)->eval()->print();
            // }
            // std::cout << "opt_test1" << std::endl;
        }
	| %empty { $$ = NULL; }
	;
plus_COMMA_test // Used in: plus_COMMA_test, opt_test_2
	: plus_COMMA_test COMMA test
	| COMMA test
	;
opt_test_2 // Used in: print_stmt
	: plus_COMMA_test opt_COMMA
	| %empty
	;
del_stmt // Used in: small_stmt
	: DEL exprlist
	;
pass_stmt // Used in: small_stmt
	: PASS
	;
flow_stmt // Used in: small_stmt
    : break_stmt    { $$ = nullptr; }
    | continue_stmt { $$ = nullptr; }
    | return_stmt   { $$ = $1; }
    | raise_stmt    { $$ = nullptr; }
    | yield_stmt    { $$ = nullptr; }
    ;
break_stmt // Used in: flow_stmt
	: BREAK
	;
continue_stmt // Used in: flow_stmt
	: CONTINUE
	;
return_stmt // Used in: flow_stmt
    : RETURN testlist
        {
            $$ = new ReturnNode($2);
            pool.add($$);
        }
    | RETURN { $$ = nullptr; }
    ;
yield_stmt // Used in: flow_stmt
	: yield_expr
	;
raise_stmt // Used in: flow_stmt
	: RAISE test opt_test_3
	| RAISE
	;
opt_COMMA_test // Used in: opt_test_3, exec_stmt
	: COMMA test
	| %empty
	;
opt_test_3 // Used in: raise_stmt
	: COMMA test opt_COMMA_test
	| %empty
	;
import_stmt // Used in: small_stmt
	: import_name
	| import_from
	;
import_name // Used in: import_stmt
	: IMPORT dotted_as_names
	;
import_from // Used in: import_stmt
	: FROM pick_dotted_name IMPORT pick_STAR_import
	;
pick_dotted_name // Used in: import_from
	: star_DOT dotted_name
	| star_DOT DOT
	;
pick_STAR_import // Used in: import_from
	: STAR
	| LPAR import_as_names RPAR
	| import_as_names
	;
import_as_name // Used in: import_as_names, star_COMMA_import_as_name
	: NAME AS NAME { delete [] $1; delete [] $3; }
	| NAME { delete [] $1; }
	;
dotted_as_name // Used in: dotted_as_names
	: dotted_name AS NAME { delete [] $3; }
	| dotted_name
	;
import_as_names // Used in: pick_STAR_import
	: import_as_name star_COMMA_import_as_name COMMA
	| import_as_name star_COMMA_import_as_name
	;
star_COMMA_import_as_name // Used in: import_as_names, star_COMMA_import_as_name
	: star_COMMA_import_as_name COMMA import_as_name
	| %empty
	;
dotted_as_names // Used in: import_name, dotted_as_names
	: dotted_as_name
	| dotted_as_names COMMA dotted_as_name
	;
dotted_name // Used in: decorator, pick_dotted_name, dotted_as_name, dotted_name
	: NAME { delete [] $1; }
	| dotted_name DOT NAME { delete [] $3; }
	;
global_stmt // Used in: small_stmt
	: GLOBAL NAME star_COMMA_NAME { delete [] $2; }
	;
star_COMMA_NAME // Used in: global_stmt, star_COMMA_NAME
	: star_COMMA_NAME COMMA NAME { delete [] $3; }
	| %empty
	;
exec_stmt // Used in: small_stmt
	: EXEC expr IN test opt_COMMA_test
	| EXEC expr
	;
assert_stmt // Used in: small_stmt
	: ASSERT test COMMA test
	| ASSERT test
	;
compound_stmt // Used in: stmt
    : if_stmt
        { $$ = nullptr; }
    | while_stmt    { $$ = nullptr; }
    | for_stmt      { $$ = nullptr; }
    | try_stmt      { $$ = nullptr; }
    | with_stmt     { $$ = nullptr; }
    | funcdef
        { $$ = nullptr; }
    | classdef      { $$ = nullptr; }
    | decorated     { $$ = nullptr; }
    ;
if_stmt // Used in: compound_stmt
    : IF test COLON suite star_ELIF ELSE COLON suite
        {
            $$ = nullptr;
        }
    | IF test COLON suite star_ELIF
        { $$ = nullptr; }
    ;
star_ELIF // Used in: if_stmt, star_ELIF
	: star_ELIF ELIF test COLON suite
	| %empty
	;
while_stmt // Used in: compound_stmt
	: WHILE test COLON suite ELSE COLON suite
	| WHILE test COLON suite
	;
for_stmt // Used in: compound_stmt
	: FOR exprlist IN testlist COLON suite ELSE COLON suite
	| FOR exprlist IN testlist COLON suite
	;
try_stmt // Used in: compound_stmt
	: TRY COLON suite plus_except opt_ELSE opt_FINALLY
	| TRY COLON suite FINALLY COLON suite
	;
plus_except // Used in: try_stmt, plus_except
	: plus_except except_clause COLON suite
	| except_clause COLON suite
	;
opt_ELSE // Used in: try_stmt
	: ELSE COLON suite
	| %empty
	;
opt_FINALLY // Used in: try_stmt
	: FINALLY COLON suite
	| %empty
	;
with_stmt // Used in: compound_stmt
	: WITH with_item star_COMMA_with_item COLON suite
	;
star_COMMA_with_item // Used in: with_stmt, star_COMMA_with_item
	: star_COMMA_with_item COMMA with_item
	| %empty
	;
with_item // Used in: with_stmt, star_COMMA_with_item
	: test AS expr
	| test
	;
except_clause // Used in: plus_except
	: EXCEPT test opt_AS_COMMA
	| EXCEPT
	;
pick_AS_COMMA // Used in: opt_AS_COMMA
	: AS
	| COMMA
	;
opt_AS_COMMA // Used in: except_clause
	: pick_AS_COMMA test
	| %empty
	;
suite // Used in: funcdef, if_stmt, star_ELIF, while_stmt, for_stmt, try_stmt, plus_except, opt_ELSE, opt_FINALLY, with_stmt, classdef
    : simple_stmt
        {
            //
            $$ = $1;
            std::cout << "suite: simple_stmt" << std::endl;
        }
    | NEWLINE INDENT plus_stmt DEDENT
        {
            //
            $$ = $3;
            std::cout << "NEWLINE INDENT plus_stmt DEDENT" << std::endl;
        }
    ;
plus_stmt // Used in: suite, plus_stmt
    : plus_stmt stmt
        {
            $$ = $1;
            dynamic_cast<SuiteNode*>($$)->add($2);
        }
    | stmt
        {
            $$ = new SuiteNode();
            dynamic_cast<SuiteNode*>($$)->add($1);
            pool.add($$);
        }
    ;
testlist_safe // Used in: list_for
	: old_test plus_COMMA_old_test opt_COMMA
	| old_test
	;
plus_COMMA_old_test // Used in: testlist_safe, plus_COMMA_old_test
	: plus_COMMA_old_test COMMA old_test
	| COMMA old_test
	;
old_test // Used in: testlist_safe, plus_COMMA_old_test, old_lambdef, list_if, comp_if
	: or_test
	| old_lambdef
	;
old_lambdef // Used in: old_test
	: LAMBDA varargslist COLON old_test
	| LAMBDA COLON old_test
	;
test // Used in: opt_EQUAL_test, print_stmt, star_COMMA_test, opt_test, plus_COMMA_test, raise_stmt, opt_COMMA_test, opt_test_3, exec_stmt, assert_stmt, if_stmt, star_ELIF, while_stmt, with_item, except_clause, opt_AS_COMMA, opt_IF_ELSE, listmaker, testlist_comp, lambdef, subscript, opt_test_only, sliceop, testlist, dictorsetmaker, star_test_COLON_test, opt_DOUBLESTAR_test, pick_argument, argument, testlist1
    : or_test opt_IF_ELSE { $$ = $1; }
    | lambdef
        {
            $$ = NULL;
            std::cout << "impossible lambdef" << std::endl;
        }
    ;
opt_IF_ELSE // Used in: test
    : IF or_test ELSE test
        { std::cout << "test: opt_IF_ELSE" << std::endl; }
    | %empty
    ;
or_test // Used in: old_test, test, opt_IF_ELSE, or_test, comp_for
    : and_test { $$ = $1; }
    | or_test OR and_test { $$ = $1; }
    ;
and_test // Used in: or_test, and_test
    : not_test { $$ = $1; }
    | and_test AND not_test { $$ = $1; }
    ;
not_test // Used in: and_test, not_test
    : NOT not_test { $$ = $2; }
    | comparison { $$ = $1; }
    ;
comparison // Used in: not_test, comparison
    : expr { $$ = $1; }
    | comparison comp_op expr
        {
            switch ($2) {
                case OP_LESS :

                    break;
                case OP_GREATER :

                    break;
                case OP_EQEQUAL :

                    break;
                case OP_GREATEREQUAL :

                    break;
                case OP_LESSEQUAL :

                    break;
                case OP_NOTEQUAL :

                    break;
                default :
                    throw std::string("comp_op error");
                    break;
            }
            $$ = $1;
        }
    ;
comp_op // Used in: comparison
    : LESS         { $$ = $1; }
    | GREATER      { $$ = $1; }
    | EQEQUAL      { $$ = $1; }
    | GREATEREQUAL { $$ = $1; }
    | LESSEQUAL    { $$ = $1; }
    | GRLT         { $$ = 0; }
    | NOTEQUAL     { $$ = $1; }
    | IN           { $$ = 0; }
    | NOT IN       { $$ = 0; }
    | IS           { $$ = 0; }
    | IS NOT       { $$ = 0; }
    ;
expr // Used in: exec_stmt, with_item, comparison, expr, exprlist, star_COMMA_expr
    : xor_expr
        {
            $$ = $1;
            //std::cout << "expr1" << std::endl;
        }
    | expr BAR xor_expr
        {
            $$ = $1;
            //std::cout << "expr2" << std::endl;
        }
    ;
xor_expr // Used in: expr, xor_expr
	: and_expr { $$ = $1; }
	| xor_expr CIRCUMFLEX and_expr { $$ = $1; }
	;
and_expr // Used in: xor_expr, and_expr
	: shift_expr { $$ = $1; }
	| and_expr AMPERSAND shift_expr { $$ = $1; }
	;
shift_expr // Used in: and_expr, shift_expr
	: arith_expr { $$ = $1; }
	| shift_expr pick_LEFTSHIFT_RIGHTSHIFT arith_expr { $$ = $1; }
	;
pick_LEFTSHIFT_RIGHTSHIFT // Used in: shift_expr
	: LEFTSHIFT
	| RIGHTSHIFT
	;
arith_expr // Used in: shift_expr, arith_expr
    : term { $$ = $1; }
    | arith_expr pick_PLUS_MINUS term
        {
            switch ($2) {
                case OP_PLUS:
                    $$ = new AddBinaryNode($1, $3);
                    pool.add($$);
                break;
                case OP_MINUS:
                    $$ = new SubBinaryNode($1, $3);
                    pool.add($$);
                break;
            }
        }
	;
pick_PLUS_MINUS // Used in: arith_expr
	: PLUS
      { $$ = $1; }
	| MINUS
      { $$ = $1; }
	;
term // Used in: arith_expr, term
	: factor
        {
            $$ = $1;
            //std::cout << "term1" << std::endl;
        }
	| term pick_multop factor
        {
            switch ($2) {
                case OP_STAR:
                    $$ = new MulBinaryNode($1, $3);
                    pool.add($$);
                    break;
                case OP_SLASH:
                    $$ = new DivBinaryNode($1, $3);
                    pool.add($$);
                    break;
                case OP_PERCENT:
                    $$ = new ModBinaryNode($1, $3);
                    pool.add($$);
                    break;
                case OP_DOUBLESLASH:
                    $$ = new FlrDivBinaryNode($1, $3);
                    pool.add($$);
                    break;
            }
            //std::cout << "term2" << std::endl;
        }
	;
pick_multop // Used in: term
    : STAR //multiply
      { $$ = $1; }
    | SLASH //divide
      { $$ = $1; }
    | PERCENT //mod
      { $$ = $1; }
    | DOUBLESLASH //div
      { $$ = $1; }
    ;
factor // Used in: term, factor, power
    : pick_unop factor
        {
            switch ($1) {
                case OP_PLUS:
                    $$ = new PositiveUnaryNode($2);
                    pool.add($$);
                    break;
                case OP_MINUS:
                    $$ = new NegativeUnaryNode($2);
                    pool.add($$);
                    break;
            }
        }
    | power
    {
        $$ = $1;
        //std::cout << "factor2" << std::endl;
    }
    ;
pick_unop // Used in: factor
	: PLUS { $$ = $1; }
	| MINUS { $$ = $1; }
	| TILDE { $$ = 0; }
	;
power // Used in: factor
    : atom star_trailer DOUBLESTAR factor
        {
            if ($3 == OP_DOUBLESTAR) {
                $$ = new ExpBinaryNode($1, $4);
                pool.add($$);
            }
            else {
                std::cout << "DOUBLESTAR wrong" << std::endl;
            }
        }
    | atom star_trailer
        {
            if($2) {
                std::cout << "call function" << std::endl;
            }
            else {
                $$ = $1;
            }
            //std::cout << "power2" << std::endl;
        }
    ;
star_trailer // Used in: power, star_trailer
    : star_trailer trailer { $$ = nullptr; }
    | %empty { $$ = nullptr; }
    ;
atom // Used in: power
    : LPAR opt_yield_test RPAR
        {
            $$ = $2;
            // std::cout << "atom1" << std::endl;
            if (!$2) { std::cout << "empty parens" << std::endl; }
        }
    | LSQB opt_listmaker RSQB
        { $$ = NULL; std::cout << "impossible atom2" << std::endl; }
    | LBRACE opt_dictorsetmaker RBRACE
        { $$ = NULL; std::cout << "impossible atom3" << std::endl; }
    | BACKQUOTE testlist1 BACKQUOTE
        { $$ = NULL; std::cout << "impossible atom4" << std::endl; }
    | NAME
        {
            $$ = new IdentNode($1);
            delete [] $1;
            pool.add($$);
        }
    | INT
        {
            $$ = new IntLiteral($1);
            pool.add($$);
        }
    | FLOAT
        {
            $$ = new FloatLiteral($1);
            pool.add($$);
        }
    | plus_STRING { $$ = NULL; std::cout << "impossible atom8" << std::endl; }
    ;
pick_yield_expr_testlist_comp // Used in: opt_yield_test
	: yield_expr { $$ = $1; }
	| testlist_comp { $$ = $1; }
	;
opt_yield_test // Used in: atom
	: pick_yield_expr_testlist_comp { $$ = $1; }
	| %empty { $$ = NULL; }
	;
opt_listmaker // Used in: atom
	: listmaker
	| %empty
	;
opt_dictorsetmaker // Used in: atom
	: dictorsetmaker
	| %empty
	;
plus_STRING // Used in: atom, plus_STRING
	: plus_STRING STRING
	| STRING
	;
listmaker // Used in: opt_listmaker
	: test list_for
	| test star_COMMA_test opt_COMMA
	;
testlist_comp // Used in: pick_yield_expr_testlist_comp
	: test comp_for { $$ = $1; }
	| test star_COMMA_test opt_COMMA { $$ = $1; }
	;
lambdef // Used in: test
	: LAMBDA varargslist COLON test
	| LAMBDA COLON test
	;
trailer // Used in: star_trailer
	: LPAR opt_arglist RPAR
	| LSQB subscriptlist RSQB
	| DOT NAME { delete [] $2; }
	;
subscriptlist // Used in: trailer
	: subscript star_COMMA_subscript COMMA
	| subscript star_COMMA_subscript
	;
star_COMMA_subscript // Used in: subscriptlist, star_COMMA_subscript
	: star_COMMA_subscript COMMA subscript
	| %empty
	;
subscript // Used in: subscriptlist, star_COMMA_subscript
	: DOT DOT DOT
	| test
	| opt_test_only COLON opt_test_only opt_sliceop
	;
opt_test_only // Used in: subscript
	: test
	| %empty
	;
opt_sliceop // Used in: subscript
	: sliceop
	| %empty
	;
sliceop // Used in: opt_sliceop
	: COLON test
	| COLON
	;
exprlist // Used in: del_stmt, for_stmt, list_for, comp_for
	: expr star_COMMA_expr COMMA
	| expr star_COMMA_expr
	;
star_COMMA_expr // Used in: exprlist, star_COMMA_expr
	: star_COMMA_expr COMMA expr
	| %empty
	;
testlist // Used in: expr_stmt, pick_yield_expr_testlist, return_stmt, for_stmt, opt_testlist, yield_expr
    : test star_COMMA_test COMMA
        {
            $$ = $1;
            //std::cout << "testlist1" << std::endl;
        }
    | test star_COMMA_test
        {
            $$ = $1;
            // std::cout << "testlist 2" << std::endl;
            // if(!$1) { std::cout << "testlist 2 NULL error" << std::endl; }
            // else {
            //     if(($1)->eval()) {
            //         std::cout << "print: " << std::endl;
            //         ($1)->eval()->print();
            //     }
            // }
            // ($1)->eval()->print();
        }
    ;
dictorsetmaker // Used in: opt_dictorsetmaker
	: test COLON test pick_for_test_test
	| test pick_for_test
	;
star_test_COLON_test // Used in: star_test_COLON_test, pick_for_test_test
	: star_test_COLON_test COMMA test COLON test
	| %empty
	;
pick_for_test_test // Used in: dictorsetmaker
	: comp_for
	| star_test_COLON_test opt_COMMA
	;
pick_for_test // Used in: dictorsetmaker
	: comp_for
	| star_COMMA_test opt_COMMA
	;
classdef // Used in: decorated, compound_stmt
	: CLASS NAME LPAR opt_testlist RPAR COLON suite { delete [] $2; }
	| CLASS NAME COLON suite { delete [] $2; }
	;
opt_testlist // Used in: classdef
	: testlist
	| %empty
	;
arglist // Used in: opt_arglist
	: star_argument_COMMA pick_argument
	;
star_argument_COMMA // Used in: arglist, star_argument_COMMA
	: star_argument_COMMA argument COMMA
	| %empty
	;
star_COMMA_argument // Used in: star_COMMA_argument, pick_argument
	: star_COMMA_argument COMMA argument
	| %empty
	;
opt_DOUBLESTAR_test // Used in: pick_argument
	: COMMA DOUBLESTAR test
	| %empty
	;
pick_argument // Used in: arglist
	: argument opt_COMMA
	| STAR test star_COMMA_argument opt_DOUBLESTAR_test
	| DOUBLESTAR test
	;
argument // Used in: star_argument_COMMA, star_COMMA_argument, pick_argument
	: test opt_comp_for
	| test EQUAL test
	;
opt_comp_for // Used in: argument
	: comp_for
	| %empty
	;
list_iter // Used in: list_for, list_if
	: list_for
	| list_if
	;
list_for // Used in: listmaker, list_iter
	: FOR exprlist IN testlist_safe list_iter
	| FOR exprlist IN testlist_safe
	;
list_if // Used in: list_iter
	: IF old_test list_iter
	| IF old_test
	;
comp_iter // Used in: comp_for, comp_if
	: comp_for
	| comp_if
	;
comp_for // Used in: testlist_comp, pick_for_test_test, pick_for_test, opt_comp_for, comp_iter
	: FOR exprlist IN or_test comp_iter
	| FOR exprlist IN or_test
	;
comp_if // Used in: comp_iter
	: IF old_test comp_iter
	| IF old_test
	;
testlist1 // Used in: atom, testlist1
	: test
	| testlist1 COMMA test
	;
yield_expr // Used in: pick_yield_expr_testlist, yield_stmt, pick_yield_expr_testlist_comp
    : YIELD testlist { std::cout << "impossible YIELD" << std::endl; $$ = $2; }
    | YIELD { std::cout << "impossible YIELD" << std::endl; }
    ;
star_DOT // Used in: pick_dotted_name, star_DOT
	: star_DOT DOT
	| %empty
	;

%%

#include <stdio.h>
void yyerror (const char *s)
{
    if(yylloc.first_line > 0)	{
        fprintf (stderr, "%d.%d-%d.%d:", yylloc.first_line, yylloc.first_column,
	                                     yylloc.last_line,  yylloc.last_column);
    }
    fprintf(stderr, " %s with [%s]\n", s, yytext);
}
